<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 經典版</title>
    <style>
        :root {
            --bg-color: #faf8ef;
            --grid-bg: #bbada0;
            --tile-empty: #cdc1b4;
            --text-dark: #776e65;
            --text-light: #f9f6f2;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-dark);
            font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        .heading {
            width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { font-size: 60px; font-weight: bold; margin: 0; }

        .scores-container { display: flex; gap: 5px; }
        .score-box {
            background: #bbada0;
            padding: 5px 20px;
            border-radius: 3px;
            color: white;
            text-align: center;
            min-width: 60px;
        }
        .score-box .label { font-size: 13px; text-transform: uppercase; display: block; color: #eee4da; }
        .score-box .value { font-size: 20px; font-weight: bold; }

        .above-game {
            width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
        }

        .restart-btn {
            background: #8f7a66;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 3px;
            font-weight: bold;
            cursor: pointer;
            border: none;
        }

        /* 遊戲主體 */
        .game-container {
            width: 400px;
            height: 400px;
            background: var(--grid-bg);
            border-radius: 6px;
            position: relative;
            padding: 15px;
            box-sizing: border-box;
            touch-action: none;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            height: 100%;
        }

        .grid-cell {
            width: 76.25px;
            height: 76.25px;
            background: var(--tile-empty);
            border-radius: 3px;
        }

        .tile-container { position: absolute; top: 15px; left: 15px; right: 15px; bottom: 15px; }

        .tile {
            width: 76.25px;
            height: 76.25px;
            position: absolute;
            background: #eee4da;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            font-weight: bold;
            transition: transform 0.1s ease-in-out, background 0.1s;
        }

        /* 數字顏色樣式 */
        .tile-2 { background: #eee4da; color: var(--text-dark); }
        .tile-4 { background: #ede0c8; color: var(--text-dark); }
        .tile-8 { background: #f2b179; color: var(--text-light); }
        .tile-16 { background: #f59563; color: var(--text-light); }
        .tile-32 { background: #f67c5f; color: var(--text-light); }
        .tile-64 { background: #f65e3b; color: var(--text-light); }
        .tile-128 { background: #edcf72; color: var(--text-light); font-size: 30px; }
        .tile-256 { background: #edcc61; color: var(--text-light); font-size: 30px; }
        .tile-512 { background: #edc850; color: var(--text-light); font-size: 30px; }
        .tile-1024 { background: #edc53f; color: var(--text-light); font-size: 25px; }
        .tile-2048 { background: #edc22e; color: var(--text-light); font-size: 25px; }

        @media screen and (max-width: 450px) {
            .heading, .above-game, .game-container { width: 300px; }
            .game-container { height: 300px; padding: 10px; }
            .grid-cell, .tile { width: 57.5px; height: 57.5px; font-size: 25px; }
            .tile-container { top: 10px; left: 10px; }
            h1 { font-size: 40px; }
        }
    </style>
</head>
<body>

    <div class="heading">
        <h1>2048</h1>
        <div class="scores-container">
            <div class="score-box"><span class="label">SCORE</span><span id="score" class="value">0</span></div>
            <div class="score-box"><span class="label">BEST</span><span id="best" class="value">0</span></div>
        </div>
    </div>

    <div class="above-game">
        <p>合併方塊直到 <strong>2048!</strong></p>
        <button class="restart-btn" onclick="game.init()">New Game</button>
    </div>

    <div class="game-container" id="game-container">
        <div class="grid-container">
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        </div>
        <div class="tile-container" id="tile-container"></div>
    </div>

    <script>
        class Game2048 {
            constructor() {
                this.container = document.getElementById('tile-container');
                this.scoreEl = document.getElementById('score');
                this.bestEl = document.getElementById('best');
                this.size = 4;
                this.grid = [];
                this.score = 0;
                this.best = localStorage.getItem('bestScore') || 0;
                this.bestEl.innerText = this.best;
                this.init();
            }

            init() {
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
                this.score = 0;
                this.updateScore(0);
                this.addRandomTile();
                this.addRandomTile();
                this.draw();
            }

            updateScore(n) {
                this.score += n;
                this.scoreEl.innerText = this.score;
                if (this.score > this.best) {
                    this.best = this.score;
                    this.bestEl.innerText = this.best;
                    localStorage.setItem('bestScore', this.best);
                }
            }

            addRandomTile() {
                let emptyCells = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === 0) emptyCells.push({r, c});
                    }
                }
                if (emptyCells.length > 0) {
                    let {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.grid[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            draw() {
                this.container.innerHTML = '';
                const gap = window.innerWidth <= 450 ? 10 : 15;
                const cellSize = window.innerWidth <= 450 ? 57.5 : 76.25;

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] !== 0) {
                            const tile = document.createElement('div');
                            tile.className = `tile tile-${this.grid[r][c]}`;
                            tile.innerText = this.grid[r][c];
                            tile.style.transform = `translate(${c * (cellSize + gap)}px, ${r * (cellSize + gap)}px)`;
                            this.container.appendChild(tile);
                        }
                    }
                }
            }

            move(dir) {
                let moved = false;
                const rotate = (grid) => grid[0].map((_, i) => grid.map(row => row[i]).reverse());
                
                // 根據方向旋轉陣列，統一用「向左」邏輯處理
                let tempGrid = JSON.parse(JSON.stringify(this.grid));
                if (dir === 'up') tempGrid = rotate(rotate(rotate(tempGrid)));
                if (dir === 'right') tempGrid = rotate(rotate(tempGrid));
                if (dir === 'down') tempGrid = rotate(tempGrid);

                for (let r = 0; r < this.size; r++) {
                    let row = tempGrid[r].filter(v => v !== 0);
                    for (let i = 0; i < row.length - 1; i++) {
                        if (row[i] === row[i+1]) {
                            row[i] *= 2;
                            this.updateScore(row[i]);
                            row.splice(i+1, 1);
                            moved = true;
                        }
                    }
                    while (row.length < this.size) row.push(0);
                    if (JSON.stringify(tempGrid[r]) !== JSON.stringify(row)) moved = true;
                    tempGrid[r] = row;
                }

                // 轉回原方向
                if (dir === 'up') tempGrid = rotate(tempGrid);
                if (dir === 'right') tempGrid = rotate(rotate(tempGrid));
                if (dir === 'down') tempGrid = rotate(rotate(rotate(tempGrid)));

                if (moved) {
                    this.grid = tempGrid;
                    this.addRandomTile();
                    this.draw();
                    if (this.isGameOver()) alert("Game Over!");
                }
            }

            isGameOver() {
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === 0) return false;
                        if (c < 3 && this.grid[r][c] === this.grid[r][c+1]) return false;
                        if (r < 3 && this.grid[r][c] === this.grid[r+1][c]) return false;
                    }
                }
                return true;
            }
        }

        const game = new Game2048();

        // 鍵盤監聽
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') game.move('left');
            if (e.key === 'ArrowRight') game.move('right');
            if (e.key === 'ArrowUp') game.move('up');
            if (e.key === 'ArrowDown') game.move('down');
        });

        // 手勢監聽 (手機支援)
        let touchStart = null;
        document.addEventListener('touchstart', e => touchStart = e.touches[0]);
        document.addEventListener('touchend', e => {
            if (!touchStart) return;
            let dx = e.changedTouches[0].clientX - touchStart.clientX;
            let dy = e.changedTouches[0].clientY - touchStart.clientY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) game.move(dx > 0 ? 'right' : 'left');
            } else {
                if (Math.abs(dy) > 30) game.move(dy > 0 ? 'down' : 'up');
            }
            touchStart = null;
        });
    </script>
</body>
</html>